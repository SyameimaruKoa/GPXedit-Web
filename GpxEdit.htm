<!DOCTYPE html>
<html lang="ja" >
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>GPXエディタ</title>
	<script>
	const SrUpS  = 0.5; 	//急な上りの速度比(平地を1として)
	const SrUp   = 0.8; 	//上りの速度比
	const SrDwn  = 1.15;	//下りの速度比
	const SrDwnS = 0.85; 	//急な下りの速度比
	const UpTh1  = 0.04;	//上り傾斜の閾値(4m/100m)
	const UpTh2  = 0.5;	//急な上り傾斜の閾値(50m/100m)
	const DwnTh1 = -0.04;	//下り傾斜の閾値
	const DwnTh2 = 0.5;	//急な下り傾斜の閾値
	const jumpList = [
	"丹沢/12/35.468296/139.159901",
	"奥多摩/12/35.779436/139.127785",
	"奥秩父/12/35.889328/138.701129",
	"八ヶ岳/12/35.973157/138.371695",
	"南アルプス北部/12/35.705820/138.253997",
	"南アルプス南部/12/35.486710/138.170375",
	"穂高/14/36.291827/137.657205",
	"白馬/14/36.753452/137.758470",
	"谷川岳/14/36.841189/138.930870",
	"六甲山/15/34.775094/135.262211",
	"岩手山/13/39.848780/140.994189",
	"御在所岳/15/35.019287/136.421900",
	"石狩山地/11/43.536241/142.944520",
	"久住山/13/33.099360/131.262643",
	"剣山/15/33.854081/134.095124",
	"富士山/13/35.362715/138.731133",
	];
	const HeaderTxt = '<?xml version="1.0" encoding="UTF-8"?>\n<gpx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.topografix.com/GPX/1/0" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd" creator="https://www.yamareco.com/modules/yamareco/userinfo-75709-prof.html">\n';
	</script>

	<style>
	.icon1 {
	width: 6px; height: 6px;
	border-radius: 50% 50% 50% 50%;
	border: 4px solid #ff0000;
	box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.8);
	background-color: #000000;
	position: absolute;
	}
	.icon2 {
	width: 10px; height: 10px;
	border-radius: 50% 50% 50% 50%;
	background-color: #ff00ff;
	position: absolute;
	}
	.icon3 {
	width: 10px; height: 10px;
	border-radius: 50% 50% 50% 50%;
	background-color: #4682b4;
	position: absolute;
	}
	</style>
	
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==" crossorigin=""/>
	<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" crossorigin=""></script>

</head>
<body>
	<span>【GPXエディタ V1.1】<span><br>
	<label for="selfile"><b>画面にGPXファイルをドロップするか、ボタンを押してファイルを選択してください。</b></label>
	<input type="file" multiple id="selfile"><br>

	<div id="mapWin1" style="width:620px;height:350px"></div>

	<div style="padding: 0.2em 0.3em 0.2em 0.3em; margin: 0 0; border: double 3px #6091d3; border-radius: 10px; display: inline-block;">
	<form name="selbttn1">
		<span>&nbsp;作業選択：</span><br>
		<label><input type="radio" name="mode" value="make" onchange="modeChange()" checked>&nbsp;ルート作成</label>
		<label><input type="radio" name="mode" value="edit" onchange="modeChange()" >&nbsp;トラック編集</label>
		<label><input type="radio" name="mode" value="divide" onchange="modeChange()">&nbsp;ルート分割</label>
		<label><input type="radio" name="mode" value="remove" onchange="modeChange()">&nbsp;ルート部分削除</label>
		<label><input type="radio" name="mode" value="merge" onchange="modeChange()">&nbsp;ルート結合</label><br>
		<label><input type="radio" name="mode" value="decimate" onchange="modeChange()" >&nbsp;ポイント間引き</label>
		<label><input type="radio" name="mode" value="TmChang" onchange="modeChange()" >&nbsp;時間変更</label>
		<label><input type="radio" name="mode" value="NaChang" onchange="modeChange()" >&nbsp;名前変更</label>
		<label><input type="radio" name="mode" value="reverse" onchange="modeChange()" >&nbsp;逆ルート変換</label>
		<label><input type="radio" name="mode" value="delete" onchange="modeChange()" >&nbsp;ルート削除</label><br>
		<label><input type="radio" name="mode" value="Pinfo" onchange="modeChange()" >&nbsp;ポイント情報(時間変更)</label>
		<label><input type="radio" name="mode" value="save" onchange="modeChange()" >&nbsp;ファイル出力</label>
		<label><input type="radio" name="mode" value="jump" onchange="modeChange()" >&nbsp;地図ジャンプ</label>
	</form>
	</div>
	<br>

	<font color="crimson"><span id="message1" ></span></font><br>
	<span id="message2" ></span>
	<div id="OParea1"></div>
	<div id="OParea2"></div>
	<div id="OParea3"></div>
	<div id="OParea4"></div>
	<br>

	<div ondblclick="listJump()" >
	<span>[読み込みルート]</span><br>
	<span id="message3" ></span>
	</div>

<script>

var mymap;
var readTxt = ""; // 入力ファイル
var GpxFileName = ""; // 入力ファイルの拡張子無しファイル名
var mode = "make"; // 作業モード状態
var Routes = {}; // ルート(GPXファイル)毎のデータ
var markN = 0; // トラックマーカー識別番号 markNam = "m" + markN
var MarkerList = {}; // トラックマーカーのリスト { markNam:L.marker(), ....}
var MarkerIndex = {}; // トラックマーカーのインデックス {1:[markNam,[lat, lon]], 2:[markNam,[lat, lon]], ...}
var DevideMark = {}; // 分割マーカーリスト {0:routeName , 1:L.marker(), 2:L.marker()} 
var MovedMark = {}; // 移動マーカーリスト
var AddedMark = {}; // 追加マーカーリスト
var MergeList = {}; // 結合ルートリスト
var ChoseRoute = {}; // 選択ルートのライン
var ChoseTrack = []; // edit用選択ルート及びトラック [ Routes, Track ]
var eleTile = {}; // 標高タイル保存
var NoEleFlag = 0;
const WrtMessage1 = function(str){ document.getElementById("message1").innerHTML = str;}
const WrtMessage2 = function(str){ document.getElementById("message2").innerHTML = str;}

modeChange();
document.getElementById("mapWin1").style.cursor = "crosshair"
DrwMap();

// ///////////////////////// ファイル入力 /////////////////////////

// ドラッグ&ドロップ ファイル入力
const dropArea = document.body; // ドラッグ&ドロップを許可する領域
dropArea.addEventListener("dragover", event => {
	event.preventDefault();
	event.dataTransfer.dropEffect = "copy";
});
dropArea.addEventListener("drop", event => {
   event.preventDefault();
   var files = event.dataTransfer.files;
   getFiles(files);
});
function getFiles(files){
	for (let file of files){
		var reader = new FileReader();
		reader.readAsText(file); 
		reader.onload = event => {
			var readTxt = event.target.result;
			GpxFileName = file.name.split(".")[0];
			after_file_read(readTxt, GpxFileName);
		}
	}
}

// ファイル選択ボタン入力
var obj1 = document.getElementById("selfile");
obj1.addEventListener("change",function(event){
var file = event.target.files;
	var input = document.querySelector("#selfile").files[0];
	var reader = new FileReader();  // FileReaderの作成
	reader.readAsText(file[0]);
	reader.onload = function(){
		readTxt = reader.result;
		GpxFileName = input.name.split(".")[0];
		after_file_read(readTxt, GpxFileName);
	 }
},false);

function after_file_read(readTxt, GpxFileName){
	let fieChk = 0;
	let pointer = readTxt.indexOf("</gpx>");
	( pointer !== -1 ) ? fieChk = fieChk: fieChk++;
	pointer = readTxt.indexOf("<gpx");
	( pointer !== -1 ) ? fieChk = fieChk: fieChk++;
	if (fieChk === 0 ){
//		alert("ファイルはGPXファイルです");
		if ( Routes.hasOwnProperty(GpxFileName) ){
			alert( GpxFileName + "は同名のルートがあります。\nどちらかのルート名を変更してください。");
		}else{
			make_route_datArr(readTxt, GpxFileName);
		}
	}else{
		alert( GpxFileName + "はGPXファイルではありません");
		GpxFileName = "";
		document.getElementById("txt_area").value = readTxt;
	}
}

// 文字列entStrのpinterの位置から<trkptを検索しtrkptの経度、緯度、標高、時間を返す
// 引数：(検索文字列、検索位置) 返値：[pointer, Lat, Lon, ele, strTime] "trkpt"が見つからない時はpointerに-1
function get_trkptDat(entStr, pointer){
	pointer = entStr.indexOf("<trkpt",pointer);
	if (pointer === -1){ 
		return trkpArr = [pointer, , , ,"" ]; 
	}
	let trkptStr = entStr.substring(pointer, entStr.indexOf("</trkpt>",pointer)+8);
	let Latpt = trkptStr.indexOf("lat=");
	let Lonpt = trkptStr.indexOf("lon=");
	strLat = trkptStr.substring( Latpt+5, trkptStr.indexOf('"', Latpt+5) );
	strLon = trkptStr.substring( Lonpt+5, trkptStr.indexOf('"', Lonpt+5) );
	let strEle;
	if ( trkptStr.indexOf("<ele>") !== -1 ){
		strEle = trkptStr.substring( trkptStr.indexOf("<ele>")+5, trkptStr.indexOf("</ele>") );
	}else{
		strEle = "";
	}
	let strTime;
	if ( trkptStr.indexOf("<time>") !== -1 ){
		strTime = trkptStr.substring( trkptStr.indexOf("<time>")+6, trkptStr.indexOf("</time>") );
	}else{
		strTime = "";
	}
	return [pointer, parseFloat(strLat), parseFloat(strLon), parseFloat(strEle), strTime];
}

// GPXファイルのデータを Routes{} に格納
// 引数：GPXテキスト, ファイル名, 地図のフィッティング(0:行う、!=0:行わない)
function make_route_datArr(readTxt, GpxFileName, mapfit = 0){
	let tracks = {}, trkDat = {}, trkptDat = {};
	let trkNam =ChkStr = "";
	let pointer = 0, pointer2 = 0, order = 0;
  // track毎のデータ配列 tracks{} 作成するループ
	do {
		pointer = readTxt.indexOf("<trk>", pointer);
		if (pointer !== -1){
			pointer2 = readTxt.indexOf("<trkseg>",pointer);
			ChkStr = readTxt.substring(pointer, pointer2 );
			if ( ChkStr.indexOf("<name>") != -1 ){
				pointer = readTxt.indexOf("<name>",pointer);
				trkNam = readTxt.substring( readTxt.indexOf("<name>", pointer), readTxt.indexOf("</name>", pointer) );
			}else{
				trkNam = "<name>";
			}
			trkNam += readTxt.substring( readTxt.indexOf("<number>", pointer), readTxt.indexOf("</number>", pointer) );
			trkNam += "<route>" + GpxFileName + "<order>" + order;
			if ( trkNam.indexOf("<number>") === -1 ){ 
				trkNam = trkNam.split( "<route>" )[0] + "<number><route>" + trkNam.split( "<route>" )[1];
			}
			order++;
			pointer2 = readTxt.indexOf("</trk>", pointer);
			pointer2 = readTxt.lastIndexOf("<trkpt", pointer2);
			trkptDat = {};
			let latlon = [], ele = [], time = [];
		// trackのデータ配列 trkptDat = { latlon:[], ele:[], time:[] } を作成するループ
			while (pointer < pointer2){
				let trkpArr = get_trkptDat(readTxt, pointer);
				if ( trkpArr[0] === -1 ){ breake; }
				pointer = trkpArr[0] +1;
				latlon.push( [ trkpArr[1], trkpArr[2] ] );
				if (  Number.isNaN(trkpArr[3]) ){ NoEleFlag = 1; }
				ele.push( trkpArr[3] );
				time.push( trkpArr[4] );
			}
			trkptDat["latlon"] = latlon.slice();
			trkptDat["ele"] = ele.slice();
			trkptDat["time"] = time.slice(); 
		}
		trkDat[ "trkpts" ] = Object.assign({}, trkptDat)
		tracks[trkNam] = Object.assign({}, trkDat);
	} while (pointer != -1) ;
	let header = readTxt.substring( 0, readTxt.indexOf("<trk>") );
	Routes[GpxFileName] = {};
	Routes[GpxFileName]["header"] = header;
	Routes[GpxFileName]["tracks"] = tracks;
  // trackのラインを地図に追加
	let latlonAll = [];
	for ( let track in tracks){
		let LineLatlon = Routes[GpxFileName].tracks[track].trkpts.latlon;
		let LaM = drw_trackLine( GpxFileName, track, LineLatlon );
//if (mapfit === 0 ){ mymap.fitBounds( LaM[0].getBounds() ); }
		latlonAll = latlonAll.concat( LineLatlon );
	}
	if (mapfit === 0 ){ mymap.fitBounds( latlonAll ); }
	if (NoEleFlag === 1 ){ // 標高データがない時はタイルをダウンロード
		let DLtileList = [], tileXY = []
		for ( let track in Routes[GpxFileName].tracks){
			let latlonChk = Routes[GpxFileName].tracks[track].trkpts.latlon[0].slice();
			tileXY = latLon2tile( latlonChk[0], latlonChk[1], 15 );
			DLtileList.push( [tileXY[0], tileXY[1] ] );
			for ( let i = 1; i < Routes[GpxFileName].tracks[track].trkpts.latlon.length; i++ ){
				latlonChk = Routes[GpxFileName].tracks[track].trkpts.latlon[ i ].slice();
				let tileXY = latLon2tile( latlonChk[0], latlonChk[1], 15 );
				let TileChkStr = String( tileXY[0] ) + "-" + String( tileXY[1] );
				let InTileFlag = 0;
				for ( let j = 0; j < DLtileList.length; j++ ){
					let TileInList = String( DLtileList[ j ][0] ) + "-" + String(DLtileList[ j ][1] );
					if ( TileInList === TileChkStr ){ InTileFlag++; }
				}
				if ( InTileFlag === 0 ){ DLtileList.push( [ tileXY[0], tileXY[1] ] ); }
			}
		}
		for ( let i = 0; i < DLtileList.length; i++ ){ get_tile( DLtileList[i][0],  DLtileList[i][1], 15); }
	}
	latlonAll = [];
	dsp_routeList();
	return;
}
// 標高データの無いルートにデータを追加
function add_eleDat( routeName ){
	for ( let track in Routes[routeName].tracks ){
		for ( let i = 0; i < Routes[routeName].tracks[track].trkpts.ele.length; i++ ){
			if ( Number.isNaN( Routes[routeName].tracks[track].trkpts.ele[i] ) ){
				let tmpLatlon = Routes[routeName].tracks[track].trkpts.latlon[i]
				Routes[routeName].tracks[track].trkpts.ele[i] = get_Ele( tmpLatlon[0], tmpLatlon[1] );
			}
		}
	}
}
  // 読み込みルートリスト表示
function dsp_routeList(){
	routTxt = "";
	for ( let routeName in Routes ){ routTxt += routeName + "<br>"; }
	document.getElementById("message3").innerHTML = routTxt;
	
	return;
}

// ///////////////////////// モード変更 //////////////////////// 

// モード変更時の初期化
function modeChange(){
	if ( Object.keys(Routes).length != 0 && NoEleFlag === 1){ // 標高データの無いルートに標高追加
		for ( let routeName in Routes ){ add_eleDat( routeName ); }
		NoEleFlag = 0;
	}
	mode = document.selbttn1.mode.value;
	MovedMark = {}; AddedMark = {}; WrtMessage1("");  WrtMessage2("");
	if (Object.keys(MarkerList).length != 0 ){
		for ( let M in MarkerList ){ mymap.removeLayer( MarkerList[M] ); }
		mymap.removeLayer(MarkerLine);
		MarkerList = {}; MarkerIndex = {}; 
	}
	if (Object.keys(DevideMark).length != 0 ){
		for ( let DN in DevideMark){ mymap.removeLayer(DevideMark[ DN ].mark); }
		DevideMark = {};
	}
	if (Object.keys(MergeList).length != 0 ){
		let deleLin = [];
		for ( let routeName in MergeList ){
			deleLin = MergeList[ routeName ];
			for ( let i = 0; i< deleLin.length; i++){ mymap.removeLayer( deleLin[i] ); }
		}
		MergeList = {};
	}
	if (Object.keys(ChoseRoute).length != 0 ){
		let deleLin = ChoseRoute[ Object.keys(ChoseRoute)];
		for ( let i = 0; i< deleLin.length; i++){ mymap.removeLayer( deleLin[i] ); }
		ChoseRoute = {};
	}
	if (OParea1.hasChildNodes()){ for (let i= OParea1.childNodes.length-1; i>=0; i--){ OParea1.removeChild(OParea1.childNodes[i]); } }
	if (OParea2.hasChildNodes()){ for (let i= OParea2.childNodes.length-1; i>=0; i--){ OParea2.removeChild(OParea2.childNodes[i]); } }
	if (OParea3.hasChildNodes()){ for (let i= OParea3.childNodes.length-1; i>=0; i--){ OParea3.removeChild(OParea3.childNodes[i]); } }
	if (OParea4.hasChildNodes()){ for (let i= OParea4.childNodes.length-1; i>=0; i--){ OParea4.removeChild(OParea4.childNodes[i]); } }
	switch (mode){
		case "make":
			addInputForm("OParea1", "route1", "ルート名：", "new_route" );
			addInputForm("OParea2", "track1", "トラック名：", "track" );
			addDateForm("OParea3", "SetTime" );
			addBttnForm("OParea4", "fix_make_route()", "作成トラックを確定してルート変換：", "確定" );
			break;
		case "divide":
			addInputForm("OParea1", "trk1", "前半ルート名：", "新規-1" );
			addInputForm("OParea2", "trk2", "後半ルート名：", "新規-2" );
			addBttnForm("OParea3", "divide_route()", "マーカー位置でルートを分割：", "確定" );
			break;
		case "remove":
			addRadioForm( "OParea1", 1, "selbttn2", [ "始点からマーカーまで削除", "マーカー間を削除", "マーカー間を残す", "マーカーから終点まで削除" ]);
			addBttnForm("OParea2", "patial_remove()", "ルートの部分削除：", "確定" );
			break;
		case "merge":
			addRadioForm( "OParea1", 0, "selbttn2" , [ "トラックを統合して結合", "トラックを残して結合" ]);
			addInputForm("OParea2", "trk1", "結合後のルート名：", "結合ファイル名" );
			addRadioForm( "OParea3", 0, "selbttn3" , [ "ルート1のヘッダを使用", "ルート2のヘッダを使用" ]);
			addBttnForm("OParea4", "exec_merge()", "選択ルートを結合：", "確定" );
			break;
		case "edit":
			addBttnForm("OParea1", "fix_edit()", "編集トラックを確定してルートに反映：", "確定" );
			break;
		case "decimate":
			addInputForm("OParea1", "interval", "間引き間隔(m )：", "10" );
			addBttnForm("OParea2", "exec_decimate()", "ポイントを間引く：", "実行" );
			break;
		case "TmChang":
			addDateForm("OParea1", "SetTime" );
			addBttnForm("OParea2", "change_time()", "選択ルートの時間を変更：", "変更" );
			break;
		case "reverse":
			addInputForm("OParea1", "trk1", "", "逆ルートの名前" );
			addBttnForm("OParea2", "make_reverseRoute()", "逆ルートに変換：", "実行" );
			break;
		case "NaChang":
			addInputForm("OParea1", "trk1", "", "ルート名" );
			addTxtBox("OParea2", "trk2" );
			document.getElementById("trk2").value = "<name>トラック名<number>番号"
			addBttnForm("OParea3", "change_RTname()", "ルート名、トラック名を変更：", "確定" );
			break;
		case "save":
			addInputForm("OParea1", "trk1", "保存するファイル名：", "" );
			addSaveLink("OParea2");
			break;
		case "Pinfo":
			 addOneTimeForm("OParea1", "ChgTime" );
			 addBttnForm( "OParea2", "chg_pointTime()", "", "変更" );
			break;
		case "jump":
			let PlaceArr = [];
			for ( let i = 0; i < jumpList.length; i++ ){ PlaceArr.push( jumpList[ i ].split("/")[0] ); }
			addRadioForm( "OParea1", -1 , "selbttn2", PlaceArr, "junp_select()" );
			break;
	}
	dsp_routeList(); WrtMessage1("");
}

// 実行ボタン生成
function addBttnForm( location, funcN, txt1, txt2){
	let place = document.getElementById( location );
	let SPN = document.createElement("span");
	let InpName = document.createTextNode( txt1 );
	SPN.appendChild(InpName);
	place.appendChild( SPN );
	let compo = document.createElement("input");
	compo.setAttribute("type","button");
	compo.setAttribute("onclick",funcN); 
	compo.setAttribute("size","10"); 
	compo.setAttribute("value",txt2);
	place.appendChild( compo );
}

// インプットボックス(txt)生成
function addInputForm( location, idNam, txt1, txt2){
	let place = document.getElementById( location );
	let LAB = document.createElement("label");
	LAB.setAttribute("for", idNam);
	LAB.appendChild( document.createTextNode( txt1 ) );
	place.appendChild( LAB );
	let compo = document.createElement("input");
	compo.setAttribute("type","text");
	compo.setAttribute("id", idNam);
	compo.setAttribute("maxlength","40"); 
	compo.setAttribute("size","30"); 
	compo.setAttribute("value",txt2);
	place.appendChild( compo );
}

// ラジオボタン生成 
function addRadioForm( location, chk, buttnName, txtArr, clicFunc = "" ){
	let place = document.getElementById( location );
	let Bform = document.createElement("form");
	Bform.setAttribute("name", buttnName);
	place.appendChild( Bform );
	for ( let i = 0; i < txtArr.length; i++ ){
		let LAB = document.createElement("label");
		let compo = document.createElement("input");
		compo.setAttribute("type","radio");
		compo.setAttribute("name", "ChoiceOP");
		compo.setAttribute("value", i);
		if (chk === i ){ compo.checked = "checked"; }
		compo.setAttribute("onclick", clicFunc);
		LAB.appendChild( compo );
		let Btxt = document.createTextNode( txtArr[i] + " " );
		LAB.appendChild(Btxt);
		Bform.appendChild( LAB );
	}
}

//  時間変更用インプットボックス(time)生成
function addDateForm( location, idNam ){
	let place = document.getElementById( location );
	LAB = document.createElement("label");
	LAB.setAttribute("for", idNam + "-date");
	LabeTxt = document.createTextNode( "日付：" );
	LAB.appendChild(LabeTxt);
	place.appendChild( LAB );
	compo = document.createElement("input");
	compo.setAttribute("type","date");
	compo.setAttribute("id", idNam + "-date");
	place.appendChild( compo );
	LAB = document.createElement("label");
	LAB.setAttribute("for", idNam + "-start");
	LabeTxt = document.createTextNode( " 開始時間：" );
	LAB.appendChild(LabeTxt);
	place.appendChild( LAB );
	compo = document.createElement("input");
	compo.setAttribute("type","time");
	compo.setAttribute("id", idNam + "-start");
	place.appendChild( compo );
	LAB = document.createElement("label");
	LAB.setAttribute("for", idNam + "-end");
	LabeTxt = document.createTextNode( " 終了時間：" );
	LAB.appendChild(LabeTxt);
	place.appendChild( LAB );
	compo = document.createElement("input");
	compo.setAttribute("type","time");
	compo.setAttribute("id", idNam + "-end");
	place.appendChild( compo );
}

//  インプットボックス(time)生成
function addOneTimeForm( location, idNam ){
	let place = document.getElementById( location );
	LAB = document.createElement("label");
	LAB.setAttribute("for", idNam);
	LabeTxt = document.createTextNode( " 変更時間：" );
	LAB.appendChild(LabeTxt);
	place.appendChild( LAB );
	compo = document.createElement("input");
	compo.setAttribute("type","time");
	compo.setAttribute("step","1");
	compo.setAttribute("id", idNam);
	place.appendChild( compo );
}

// テキストエリア生成
function addTxtBox( location, idNam ){
	let place = document.getElementById( location );
	let compo = document.createElement("textarea");
	compo.setAttribute("id", idNam);
	compo.setAttribute("rows","5"); 
	compo.setAttribute("cols","50"); 
	place.appendChild( compo );
//console.log(compo);
}

// ファイル出力リンク作成
function addSaveLink( location ){
	let place = document.getElementById( location );
	let SPN = document.createElement("span");
	SPN.style = "border: 1px solid #000000; background-color: #dcdcdc";
	let LinKtxt = document.createTextNode( "保存" );
	SPN.appendChild(LinKtxt);
	let compo = document.createElement("a");
	compo.setAttribute("id", "saveLocal");
//	compo.setAttribute("href", "javascript:savelog();");
	compo.setAttribute("href", "javascript:void(0);");
	compo.setAttribute("onclick", "savelog();");
	compo.appendChild( SPN );
	place.appendChild( compo );
}

// ///////////////////////// 地図操作 //////////////////////// 

// 地図表示
function DrwMap(){
	mymap = L.map('mapWin1').setView([38, 137], 4 );
	L.tileLayer(
		"https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png",
		{attribution: '<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">国土地理院</a>',maxZoom: 18}
	).addTo(mymap);
 	Markicon = L.divIcon({ className: "icon1", html: "", iconSize: [4, 4], iconAnchor: [6, 6] });
 	Sicon = L.divIcon({ className: "icon2", html: "", iconSize: [8, 8], iconAnchor: [4, 4] });
 	Gicon = L.divIcon({ className: "icon3", html: "", iconSize: [8, 8], iconAnchor: [4, 4] });
	mymap.on('click', MapClick);
}

// 地図のclickイベント(マーカー及び編集ライン(青)の設置)【make】
function MapClick(e){
	if ( mode === "make" ){
		if ( Object.keys(MarkerList).length === 0 ){
			markN = 0;
			MarkerLine = L.polyline([], { color: 'blue', weight: 5, bubblingMouseEvents: false }).addTo(mymap);
		}
		markN++;
		let mkName = "m" + markN;
		let mark = L.marker(e.latlng, {title:mkName, icon:Markicon, draggable:true, bubblingMouseEvents:false }).on('click', MarkerClick).on("dragend", MarkerDrag).on('dragstart', InhibitClick).addTo(mymap);
		MarkerList[mkName] = mark;
		let indx = Object.keys(MarkerList).length;
		MarkerIndex[  String( indx ) ] = [ mkName, [e.latlng.lat,  e.latlng.lng] ];
		MarkerLine.addLatLng(e.latlng);
		chk_eleTile(e.latlng.lat, e.latlng.lng); // 標高タイル取得
		return;
	}
}

// markerのclickイベント(マーカー削除)【make】【edit】
function MarkerClick(e){
	let delMark = e.target.options.title;
	mymap.removeLayer(e.target);
	delete MarkerList[delMark];
	let k = 0;
	let tmpArr = {};
	for ( let i = 1 ; i < Object.keys(MarkerIndex).length + 1; i++){
		let chkM = MarkerIndex[ String( i ) ];
		if ( chkM[0] === delMark ){
			k = 1;
		}else{
			tmpArr[ String(i- k) ] = MarkerIndex[ String( i ) ];
		}
	}
	MarkerIndex = Object.assign({}, tmpArr);
	MarkerLine.setLatLngs([]); // 青ライン消去
	MarkerLine.setLatLngs([mk_newLatLng(MarkerIndex)]); // 青ライン再描画
}

// start goal マーカークリック処理
function SGmarkClick(e){
	if ( mode === "make" ){ // makeモード マーカー追加
		MapClick(e);
		return;
	}
	let selTrack = e.target.options.title.split("<sg>")[0];
	let lat = e.target._latlng.lat;
	let lon = e.target._latlng.lng;
	let EO = selTrack.split("<route>")[1];
	let selctRoute = EO.split("<order>")[0];
	if ( mode === "divide"  || mode === "remove" || mode === "Pinfo"  ){ // 分割、部分削除、ポイント情報 マーカ追加
		if ( mode === "Pinfo" && Object.keys(DevideMark).length != 0 ){
		 	mymap.removeLayer(DevideMark["0"].mark);
		 	DevideMark = {};
			WrtMessage1("");
		 }
		trkptDat = Routes[selctRoute].tracks[selTrack];
		let NpInfo = nearPt_trkLinArr( lat, lon, Routes[selctRoute].tracks[selTrack].trkpts.latlon );
		let nearPt = NpInfo[0];
		if ( Object.keys(DevideMark).length === 0 ){
			let PointMark = L.marker(nearPt).on('click', MarkerClickDiv).addTo(mymap);
			DevideMark[ "0" ] = { route:selctRoute , track:selTrack, indx:NpInfo[2], mark:PointMark };
			dsp_selTrackInfo( selctRoute, selTrack, NpInfo);
		}else if ( mode === "remove" && Object.keys(DevideMark).length < 2 ){
			let PointMark = L.marker(nearPt).on('click', MarkerClickDiv).addTo(mymap);
			DevideMark[ "1" ] = { route:selctRoute , track:selTrack, indx:NpInfo[2], mark:PointMark };
		}
		return;
	}
}

// marker Drag時のクリック誤認防止【edit】
function InhibitClick(e){
	 mymap.off('click', MapClick);
}

// markerのDragイベント(マーカーの移動、MarkerList/MarkerIndexの更新、マーカー間ライン(青)の再描画)【make】【edit】
function MarkerDrag(e){
	let marker = e.target.options.title;
	let latM = e.target._latlng.lat;
	let lonM = e.target._latlng.lng;
	MovedMark[marker] = [ latM, lonM ];
	for ( let i = 1 ; i < Object.keys(MarkerIndex).length + 1; i++){
		let chkM = MarkerIndex[ String( i ) ];
		if ( chkM[0] === marker ){
			let changeP = [ marker, [latM, lonM ] ];
			MarkerIndex[ String( i ) ] = changeP;
			break;
		}
	}
	MarkerLine.setLatLngs([]);
	MarkerLine.setLatLngs([mk_newLatLng(MarkerIndex)]);
	setTimeout( function(){ mymap.on('click', MapClick); }, 10); // 誤クリック防止でoffにしたMapClickをonにする
	chk_eleTile( latM,  lonM ); // 標高タイル取得
}

// MarkerIndex{}からライン書き換え用のlatlon配列を作成
function mk_newLatLng(MarkerIndex){
	let newLatLonStr = [];
	for ( let i = 0; i < Object.keys(MarkerIndex).length; i++ ){
		let MarkD = MarkerIndex[  String(i+1)  ];
		newLatLonStr.push(MarkD[1]);
	}
	return newLatLonStr;
}

// trackライン(赤)のclickイベント【全モード】
function TrackClick(e){
	if ( mode === "make" ){ // makeモード マーカー追加
		MapClick(e);
		return;
	}
	let selctRoute, trkDat, tracks, trkptDat; // 選択したルート/トラックの名前を取得
	let lineTitl = e.target.options.title;
	let RTN = lineTitl.split("<name>");
	let selTrack = "<name>" + RTN[1];
	selctRoute = RTN[0];
	let CP = [e.latlng.lat, e.latlng.lng];
	if ( ChoseTrack.length === 0 &&  mode === "edit" ){ ChoseTrack = [ selctRoute, selTrack ]; }
	if ( mode === "divide"  || mode === "remove" || mode === "Pinfo"  ){ // 分割、部分削除、ポイント情報 マーカ追加
		if ( mode === "Pinfo" && Object.keys(DevideMark).length != 0 ){
		 	mymap.removeLayer(DevideMark["0"].mark);
		 	DevideMark = {};
			WrtMessage1("");
		 }
		trkptDat = Routes[selctRoute].tracks[selTrack];
		let NpInfo = nearPt_trkLinArr( CP[0], CP[1], Routes[selctRoute].tracks[selTrack].trkpts.latlon );
		let nearPt = NpInfo[0];
		if ( Object.keys(DevideMark).length === 0 ){
			let PointMark = L.marker(nearPt).on('click', MarkerClickDiv).addTo(mymap);
			DevideMark[ "0" ] = { route:selctRoute , track:selTrack, indx:NpInfo[2], mark:PointMark };
			dsp_selTrackInfo( selctRoute, selTrack, NpInfo);
		}else if ( mode === "remove" && Object.keys(DevideMark).length < 2 ){
			let PointMark = L.marker(nearPt).on('click', MarkerClickDiv).addTo(mymap);
			DevideMark[ "1" ] = { route:selctRoute , track:selTrack, indx:NpInfo[2], mark:PointMark };
		}
		return;
	}
	if ( mode === "merge" ){ // 結合モード 結合トラックライン表示
		if ( Object.keys(MergeList).length < 2 ){
			let MLines = [];
			for ( let track in Routes[selctRoute].tracks ){
				let LatLons = Routes[selctRoute].tracks[track].trkpts.latlon
				let mageLine = L.polyline(LatLons, {title:selctRoute, color: 'yellow', weight: 5, bubblingMouseEvents: false }).on('click', MergeLinClick).addTo(mymap);
				MLines.push( mageLine );
			}
			MergeList[ selctRoute ] = MLines;
		}
		let selRout = Object.keys(MergeList);
		let Rnam1 = selRout[0];
		( selRout.length ===2 ) ? Rnam2 = selRout[1]: Rnam2 = "";
		dsp_selTrackInfo( Rnam1, Rnam2 );
		document.getElementById("trk1").value = Rnam1 + "-" + Rnam2;
		return;
	}
	if ( mode === "edit" ){ // ルート編集モード 全trkptにマーカー設定
		if ( chk_timeDat( selctRoute ) === 1 ){ return; }
		let editTrack;
		if ( Object.keys(MarkerList).length === 0 ){
			markN = 0;
			let lineDat = [];
			editTrack = Routes[selctRoute].tracks[selTrack].trkpts.latlon;
			for (let i = 0; i < editTrack.length; i++ ){
				markN++;
				let mkName = "m" + markN;
				let mark = L.marker(editTrack[i], {title:mkName, icon:Markicon, draggable:true}).on('click', MarkerClick).on("dragend", MarkerDrag).on('dragstart', InhibitClick).addTo(mymap);
				MarkerList[mkName] = mark;
				let indx = Object.keys(MarkerList).length;
				MarkerIndex[  String( indx ) ] = [ mkName, editTrack[i] ];
				lineDat.push(editTrack[i]);
			}
			MarkerLine = L.polyline(lineDat, { color: 'blue', weight: 5, bubblingMouseEvents: false }).on('click', LineClick).addTo(mymap);
			dsp_selTrackInfo( selctRoute, selTrack, editTrack.length );
		}
		return;
	}
	if ( mode === "TmChang" || mode === "NaChang" || mode === "save" || mode === "decimate" || mode === "reverse" ){ // ルート選択
		if ( Object.keys(ChoseRoute).length === 0 ){ // 選択は1ルートのみ
			let MLines = [], NumOfPoit = 0, TrackNames = [], StartTimesArr = [], EndTimesArr = [];
			for ( let track in Routes[selctRoute].tracks ){ // 選択ルートラインの表示
				let LatLons = Routes[selctRoute].tracks[track].trkpts.latlon
				let TCRt = L.polyline(LatLons, {title:selctRoute, color: 'green', weight: 5, bubblingMouseEvents: false }).on('click', SelectRouteClick).addTo(mymap);
				MLines.push( TCRt );
				NumOfPoit += LatLons.length;
				let Times = Routes[selctRoute].tracks[track].trkpts.time;
				StartTimesArr.push( Times[0] );
				EndTimesArr.push( Times[ Times.length - 1 ] );
			}
			StartTimesArr.sort(); EndTimesArr.sort();
			let StartTimeStr = StartTimesArr[0];
			let EndTimeStr = EndTimesArr[ EndTimesArr.length -1 ];
			TrackNames = Object.keys( Routes[selctRoute].tracks );
			ChoseRoute[selctRoute] = MLines;
			dsp_selTrackInfo( selctRoute, TrackNames, NumOfPoit, StartTimeStr, EndTimeStr );
		}
		return;
	}
	if ( mode === "delete" ){ // ルート消去
		for ( let track in Routes[selctRoute].tracks ){ eras_trackLine( selctRoute, track ); }
		delete Routes[selctRoute];
		dsp_routeList();
		return;
	}
}

// 編集ライン(青)のクリックでマーカー追加
function LineClick(e){
//console.log(MarkerIndex);
	let CP = [ e.latlng.lat, e.latlng.lng ];
	let LatLons = mk_newLatLng(MarkerIndex);
	let NpInfo = nearPt_trkLinArr(CP[0], CP[1], LatLons);
	let nearPt = NpInfo[0], Mark1 = NpInfo[1], Mark2 = Mark1 + 1;
	markN++;
	let mkName = "m" + markN;
	let mark = L.marker(CP, {title:mkName, icon:Markicon, draggable:true}).on('click', MarkerClick).on("dragend", MarkerDrag).on('dragstart', InhibitClick).addTo(mymap);
	MarkerList[mkName] = mark;
	AddedMark[mkName] = CP;
	let MarkerIndexTmp = {};
	for ( let i = 1 ; i <= Mark1; i++){
		MarkerIndexTmp[ String( i ) ] = MarkerIndex[ String( i ) ].slice();
	}
	MarkerIndexTmp[ String( Mark2 ) ] = [ mkName, CP ];
	for ( let i = Mark2; i < Object.keys(MarkerIndex).length +1; i++ ){
		MarkerIndexTmp[ String( i + 1 ) ] = MarkerIndex[ String( i ) ].slice();
	}
	MarkerIndex = {};
	MarkerIndex = Object.assign({}, MarkerIndexTmp);
	MarkerLine.setLatLngs([]);
	MarkerLine.setLatLngs( [mk_newLatLng(MarkerIndex)] );
	chk_eleTile(e.latlng.lat, e.latlng.lng); // 標高タイル取得
}

// 結合トラック キャンセル
function MergeLinClick(e){
	let routeName = e.target.options.title;
	let deleLin = MergeList[ routeName ];
	for ( let i = 0; i < deleLin.length; i++ ){ mymap.removeLayer( deleLin[i] ); }
	delete MergeList[ routeName ];
	let selRout = Object.keys(MergeList);
	if ( selRout.length !=0 ){
		let Rnam1 = selRout[0];
		document.getElementById("trk1").value = Rnam1+"-";
	}else{ 
		WrtMessage1("");
		document.getElementById("trk1").value = "結合ファイル名";
	}
}

// 選択ルート キャンセル（時間変更、名前変更、ファイル出力）
function  SelectRouteClick(e){
	let routeName = e.target.options.title;
	let deleLin = ChoseRoute[ routeName ];
	for ( let i = 0; i < deleLin.length; i++ ){ mymap.removeLayer( deleLin[i] );  }
	delete ChoseRoute[ routeName ];
	if ( mode === "save" ){ document.getElementById("trk1").value = ""; }
	if ( mode === "reverse" ){ document.getElementById("trk1").value = "逆ルートの名前"; }
	if ( mode === "NaChang" ){
		document.getElementById("trk1").value = "ルート名";
		document.getElementById("trk2").value = "<name>トラック名<number>番号"
	}
	WrtMessage1("");
}

// 分割マーカー削除
function MarkerClickDiv(e){
	if (  Object.keys(DevideMark).length === 1 ){
		DevideMark = {};
		WrtMessage1("");	WrtMessage2("");
	}else{
		if ( DevideMark[ "1" ].mark ===  e.target ){
			delete DevideMark[ "1" ];
		}else{
			DevideMark[ "0" ] = { ...DevideMark[ "1" ] };
			delete DevideMark[ "1" ];
		}
	}
	mymap.removeLayer(e.target);
	if ( mode === "divide" ){  dsp_selTrackInfo( "新規", "新規" ); }
	if ( mode === "Pinfo" ){ document.getElementById("ChgTime").value = ""; }
}

// クリックポイント(lat, lon)に最も近いLinePlot上の緯度経度(latlons)を求める
//  返値：[ [近傍点の緯度、経度], ClickPtの次のLinePlotインデックス番号(1~n),  nearPtのマーカーインデックス番号(0~n)]
function nearPt_trkLinArr(lat, lon, LineDat){
	let ClickPt = [ lat, lon ];
	let chkPt1 = LineDat[0].slice();
	let nearPt = chkPt1.slice();
	let Delta = 10;  let DeltaP; let mark = lineIdx = 0;
	for ( let i = 1 ; i < LineDat.length; i++ ){
		let chkPt2 = LineDat[i].slice();
		L0 = Math.sqrt( (chkPt2[0] - chkPt1[0])**2 + (chkPt2[1] - chkPt1[1])**2 );
		L1 = Math.sqrt( (ClickPt[0] - chkPt1[0])**2 + (ClickPt[1] - chkPt1[1])**2 );
		L2 = Math.sqrt( (ClickPt[0] - chkPt2[0])**2 + (ClickPt[1] - chkPt2[1])**2 );
		DeltaP = L1 + L2 - L0;
		if ( Delta > DeltaP ){
			 Delta = DeltaP;
			 if ( L1 < L2 ){
			 	nearPt = chkPt1.slice()
			 	mark = i - 1; // nearPtのマーカーインデックス番号(0~n)
			 }else{
			 	nearPt = chkPt2.slice();
			 	mark = i;
			 }
			 lineIdx = i; // クリックポイントが何番目のライン上かのインデックス番号(1~n)
		}
		chkPt1 = chkPt2.slice();
	}
	return [ nearPt, lineIdx, mark ];
}

// 選択したルートの情報を表示する
function dsp_selTrackInfo( selctRoute, TrackNames, NumOfPoit, StartTime, EndTime ){
	if ( mode === "edit" ){ WrtMessage1( `選択ルート：${selctRoute}、選択トラック：${TrackNames}、ポイント数：${NumOfPoit}` ); }
	if ( mode === "merge" ){ (TrackNames === "") ? WrtMessage1( `選択ルート1：${selctRoute}` ): WrtMessage1( `選択ルート1：${selctRoute}、選択ルート2：${TrackNames} ` ); }
	if ( mode === "decimate" ){ WrtMessage1( `選択ルート：${selctRoute}　  ポイント数：${NumOfPoit}` ); }
	if ( mode === "NaChang" ){ 
		let TrackNamesTxt = "";
		for ( let i = 0; i < TrackNames.length; i++ ){ TrackNamesTxt += TrackNames[ i ].split("<route>")[0] + "\n"; }
		document.getElementById("trk1").value = selctRoute;
		document.getElementById("trk2").value = TrackNamesTxt; 
		WrtMessage1( `選択ルート：${selctRoute}、 トラック数 = ${TrackNames.length} ` );
	}
	if ( mode === "reverse" ){
		document.getElementById("trk1").value = selctRoute+ "Rev";
	}
	if ( mode === "TmChang" || mode === "reverse" ){
		let strDate, DayStr, stTimStr, edDate, DayEnd, edTimStr;
		if ( StartTime != "" ){
			let stTimObj = new Date( StartTime );
			strDate =  stTimObj.toLocaleString().split(' ');
			DayStr = strDate[0];
			stTimStr = strDate[1];
		}else{
			DayStr = "";
			stTimStr = "NoData";
		}
		if ( EndTime != "" ){
			let edTimObj = new Date( EndTime );
			edDate =  edTimObj.toLocaleString().split(' ');
			DayEnd = edDate[0];
			edTimStr = edDate[1];
		}else{
			edDate = "";
			edTimStr = "NoData"
		}
		WrtMessage1( ` 選択ルート：${selctRoute}　 ${DayStr} ${stTimStr} ～ ${DayEnd} ${edTimStr}` );
	}
	if ( mode === "divide" ){
		document.getElementById("trk1").value = `${selctRoute}-1`;
		document.getElementById("trk2").value = `${selctRoute}-2`;
	}
	if ( mode === "save" ){
		WrtMessage1( `選択ルート：${selctRoute}` );
		document.getElementById("trk1").value = `${selctRoute}_ed`;
	}
	if ( mode === "Pinfo" ){
		let lat = NumOfPoit[0][0], lon = NumOfPoit[0][1];
		let ele = Routes[selctRoute].tracks[TrackNames].trkpts.ele[ NumOfPoit[2] ];
		let Ptime = Routes[selctRoute].tracks[TrackNames].trkpts.time[ NumOfPoit[2] ];
		let PtimeSt;
		if ( Ptime != ""){
			let PtimeObj = new Date( Ptime );
			PtimeStr =  PtimeObj.toLocaleString();
			PtimeStr =  PtimeStr.split(" ")[1];
			PtimeStrSpl = PtimeStr.split(":");
			if (PtimeStrSpl[0].length === 1){ PtimeStrSpl[0] = "0" + PtimeStrSpl[0]; }
			PtimeStr =  PtimeStrSpl[0] + ":" + PtimeStrSpl[1];
			document.getElementById("ChgTime").value = PtimeStr;
		}else{
			PtimeStr = "No data";
			document.getElementById("ChgTime").value = "";
		}
		let RN = TrackNames.split("<number>"); let NN = RN[1].split("<route>");
		WrtMessage1( `<font color="black">ルート[<b>${selctRoute}</b>]トラック[<b>${RN[0]}</b>]number[<b>${NN[0]}</b>]  時間[<b>${PtimeStr}</b>]</font>` );
		WrtMessage2( `<b>N</b>${lat} <b>E</b>${lon}、 標高${ele}m、 index[${NumOfPoit[2]}]` );
	}
}

// ///////////////////////// 共通関数 //////////////////////// 

// トラックラインの描画
function drw_trackLine( route, track, LineLatlon ){
	let linTitl = route+track;
	let trackLine = L.polyline(LineLatlon, {title:linTitl, color: 'red', weight: 5, bubblingMouseEvents: false }).on('click', TrackClick).addTo(mymap);
	let Spoint = LineLatlon[0], Gpoint = LineLatlon[ LineLatlon.length -1 ];
	let Smark = L.marker(Spoint, {title:track+"<sg>S", icon:Sicon }).on('click', SGmarkClick).addTo(mymap);
	let Gmark = L.marker(Gpoint, {title:track+"<sg>G", icon:Gicon }).on('click', SGmarkClick).addTo(mymap);
	Routes[route].tracks[track].line = trackLine;
	Routes[route].tracks[track].icon = [ Smark, Gmark ];
	return [ trackLine, [ Smark, Gmark ] ];
}

// トラックラインの消去
function eras_trackLine( route, track ){
	mymap.removeLayer(Routes[route].tracks[track].line);
	mymap.removeLayer(Routes[route].tracks[track].icon[0]);
	mymap.removeLayer(Routes[route].tracks[track].icon[1]);
}

// ＊＊＊＊＊＊＊ 標高タイル ダウンロード ＊＊＊＊＊＊＊

// lat, lon がダウンロード済み標高タイルにあるかをチェック、無ければ標高タイルをダウンロード
function chk_eleTile(lat, lon){
	let tileInfo = latLon2tile( lat, lon, 15 );
	let DEM5A = `${15}/${tileInfo[0]}/${tileInfo[1]}`;
	let DEM10B = `${14}/${Math.floor(tileInfo[0]/2)}/${Math.floor(tileInfo[1]/2)}`;
	if ( ( eleTile.hasOwnProperty(DEM5A) === false ) && ( eleTile.hasOwnProperty(DEM10B) === false ) ){
		get_tile( tileInfo[0],  tileInfo[1], 15);
	}
}

// サーバーから標高タイルを取得して eleTile = {} に zoom/tileX/tileY のキーで格納
function get_tile( tileX, tileY, zoom){ 
	let url = `https://cyberjapandata.gsi.go.jp/xyz/dem5a/${zoom}/${tileX}/${tileY}.txt`;
	if ( zoom === 14 ){url = `https://cyberjapandata.gsi.go.jp/xyz/dem/${zoom}/${tileX}/${tileY}.txt`; }
	let request = new XMLHttpRequest(); // XMLHttpRequest オブジェクトの作成
	request.ontimeout = function () { WrtMessage1( "タイムアウト" ); };
	request.onreadystatechange = function(){
		if (request.readyState == 4){
		    if (request.status == 200){
				eleTile[`${zoom}/${tileX}/${tileY}`] = request.responseText;
				tileChk(zoom, tileX, tileY, "ok");
				return;
			}else{
//	console.log( "error " + request.status );
				tileChk(zoom, tileX, tileY, "error");
				return;
			}
		}
	};
	request.open("GET", url, true); // HTTPリクエストを初期化(同期)
	request.timeout = 2000;
	request.send(null); // HTTPリクエストをサーバーに送信
}

// 標高タイルダウンロード後のチェック、DEM5が無いか、データに"e" が入っている時はDEM10を再ダウンロード
function tileChk(zoom,  tileX,  tileY, responce){
	 if ( ( zoom === 15 ) && ( responce === "error" ) ){
	 	get_tile( Math.floor(tileX/2), Math.floor(tileY/2), 14);
	 	return;
	 }
	 if ( ( zoom === 15 ) && ( responce === "ok" ) ){
	 	let tileTxt = eleTile[`${zoom}/${tileX}/${tileY}`];
	 	if (tileTxt.indexOf("e") != -1 ){
// console.log(` "e" in ${zoom}/${tileX}/${tileY}.`);
	 		get_tile( Math.floor(tileX/2), Math.floor(tileY/2), 14);
	 		return;
	 	}
	 }
}

// ＊＊＊＊＊＊＊ 標高データ操作関連 ＊＊＊＊＊＊＊

// 緯度,経度,ズームレベルからタイル、ピクセル座標を求める
// 引数：(緯度, 緯度, ズームレベル) 返値：[ tX, tY,  tpX, tpY ] タイル座標X,Y、タイル内ピクセル座標X,Y、
function latLon2tile(latVal, lonVal, zoomVal){ 
	const L = 85.05112878; // 最大緯度
	let lat = parseFloat(latVal); // 緯度
	let lon = parseFloat(lonVal); // 経度
	let zoom = parseInt(zoomVal); // ズームレベル
  // ピクセル座標
	let pX = parseInt(Math.pow(2, zoom + 7) * (lon / 180 + 1));
	let pY = parseInt((Math.pow(2, zoom + 7) / Math.PI) * ((-1 * Math.atanh(Math.sin((Math.PI / 180) * lat))) + Math.atanh(Math.sin((Math.PI / 180) * L))));
  // タイル座標
	let tX = parseInt(pX / 256);
	let tY = parseInt(pY / 256);
  // タイル内ピクセル座標
	let tpX = pX % tX + 1;
	let tpY = pY % tY + 1;
	return [ tX, tY, tpX, tpY ];
}

// 標高タイル内ピクセル座標の標高値を取り出す
// 引数：タイル内ピクセル座標X,Y、tileTxtデータ  返値：標高値(ストリング)または "e"
function get_tipixEle( tpX, tpY, tileTxt ){ 
	let pointer2, eledat;
	let pointer = 0;
	if ( tpY > 1){ for (let i = 0; i < tpY -1 ; i++){ pointer = tileTxt.indexOf("\n", pointer + 1); } }
	if ( tpX > 1){ for (let i = 0; i <tpX -1 ; i++){ pointer = tileTxt.indexOf( ","  , pointer + 1); } }
	(tpX <= 255) ? pointer2 = tileTxt.indexOf(",", pointer+1): pointer2 = tileTxt.indexOf("\n", pointer+1);
	( pointer == 0 ) ? pointer = 0: pointer = pointer + 1;
	eledat = tileTxt.substring( pointer, pointer2);
	return eledat;
}

// ダウンロード済みタイルからlat, lonの座標の標高値を得る。戻り値は標高(数値)
function get_Ele( lat, lon ){
	let tileInfo = latLon2tile( lat, lon, 15 );
	let tileKey = `${15}/${tileInfo[0]}/${tileInfo[1]}`;
	let tileTxt = "", eledat = "";
	if (eleTile.hasOwnProperty(tileKey) === true ){
		tileTxt = eleTile[tileKey]; 
		eledat = get_tipixEle( tileInfo[2], tileInfo[3], tileTxt );
		if ( eledat === "e" ){
			tileInfo = latLon2tile( lat, lon, 14 );
			tileKey = `${14}/${tileInfo[0]}/${tileInfo[1]}`;
			tileTxt = eleTile[tileKey]; 
		eledat = get_tipixEle( tileInfo[2], tileInfo[3], tileTxt );
		}
	}else{ 
		tileInfo = latLon2tile( lat, lon, 14 );
		tileKey = `${14}/${tileInfo[0]}/${tileInfo[1]}`;
		tileTxt = eleTile[tileKey]; 
		eledat = get_tipixEle( tileInfo[2], tileInfo[3], tileTxt );
	}
	return Number(eledat) ;
}

// 緯度経度配列 [ [lat, lon], ...] に対応する標高配列 [ele0, ele1, ele2 ...]を作成 ( 標高値は eleTile のデータ )
function make_eleArr(latlonArr){
	let eleArr = [];
	for ( let i = 0;  i < latlonArr.length; i++ ){
		let  lat = latlonArr[i][0]; let lon = latlonArr[i][1];
		let eledat = get_Ele( lat, lon )
		eleArr.push( Number(eledat) );
	}
	return eleArr;
}

// ＊＊＊＊＊＊＊ 時間変更処理関連 ＊＊＊＊＊＊＊

// 時間データのチェック
function chk_timeDat( routeName ){
	for ( let track in  Routes[ routeName ].tracks ){
		for ( let i = 0; i < Routes[ routeName ].tracks[track].trkpts.time.length; i ++ ){
			if ( Routes[ routeName ].tracks[track].trkpts.time[i] === "" ){
				alert(`ルート( ${routeName} )に時間データがありません。\n時間変更で時間を設定してください。`);
				return 1;
			}
		}
	}
	return 0;
}

// 2つの緯度、経度から２点間の距離を求める (ヒュベニの公式）
function hubeny(ido1, keido1, ido2, keido2){ 
	let P = (ido1 + ido2) / 2 * Math.PI / 180;
	let dP = (ido1 - ido2) * Math.PI / 180;
	let dR = (keido1 - keido2) * Math.PI / 180;
	let M = 6334834 / Math.sqrt(Math.pow((1 - 0.006674 * Math.sin(P) * Math.sin(P)),3));
	let N = 6377397 / Math.sqrt(1 - 0.006674 * Math.sin(P) * Math.sin(P));
	return D = Math.sqrt((M * dP) * (M * dP) + (N * Math.cos(P) * dR) * (N * Math.cos(P) * dR));
}

// 開始から終了時間までを緯度経度と標高配列に従って配分し、ISOフォーマットの時間配列を作成
function make_timeArr( latlonArr, eleArr, startTime, endTime ){
	let startTmObj = new Date( startTime);
	let endTmObj = new Date( endTime);
	let timeDiffS2E = endTmObj.getTime() - startTmObj.getTime();
	let timeArr = [ startTmObj.toISOString().split('.')[0] +"Z" ], TrFactor = [];
	for ( let i = 0; i < latlonArr.length - 1; i++ ){
		let lat1 = latlonArr[ i ][0], lon1 = latlonArr[ i ][1], ele1 = eleArr[ i ];
		let lat2 = latlonArr[ i + 1][0], lon2 = latlonArr[ i +1 ][1], ele2 = eleArr[ i +1 ];
		let DS = get_DiSr(lat1, lon1, lat2, lon2, ele1, ele2 );
		TrFactor.push( DS[0] / DS[1] );
	}
	let TimeRate = timeDiffS2E / ( TrFactor.reduce((sum, element) => sum + element, 0) );
	for ( let i = 0; i < TrFactor.length - 1; i++ ){
		let addTime = TrFactor[i] * TimeRate;
		startTmObj.setMilliseconds( startTmObj.getMilliseconds() + addTime );
		timeArr.push( startTmObj.toISOString().split('.')[0] + "Z" );
	}
	timeArr.push( endTmObj.toISOString().split('.')[0] + "Z" );
	return timeArr;
}

// ２点間の経緯度と標高から、距離と速度係数を返す
function get_DiSr(lat1, lon1, lat2, lon2, ele1, ele2 ){
	let PtDis = hubeny(lat1, lon1, lat2, lon2);
	let PtEle = ele2 - ele1; 
	let Balo, SR;
	( PtDis === 0) ?  Balo = 0: Balo = PtEle / PtDis;
	if ( Balo >= UpTh2){ 
		SR = SrUpS;
	}else if ((UpTh2 > Balo) && (Balo >= UpTh1)){ 
		SR = SrUp;
	}else if ((UpTh1 > Balo) && ( Balo > DwnTh1)){ 
		SR = 1;
	}else if ((DwnTh1 >= Balo) && (Balo > DwnTh2)){ 
		SR = SrDwn;
	}else if ( DwnTh2 >= Balo ){
		SR = SrDwnS;
	}
	return [ PtDis, SR ];
}

// ///////////////////////// 実行 //////////////////////// 

// "make" ルート確定 
function fix_make_route(){
	if ( Object.keys(MarkerIndex).length === 0){ return; }
	let routeName = document.getElementById("route1").value;
	let trackName  = document.getElementById("track1").value;
	let theDate = document.getElementById("SetTime-date").value;
	let startTime = document.getElementById("SetTime-start").value;
	let endTime = document.getElementById("SetTime-end").value;
	startTime = theDate + " " + startTime;  endTime =  theDate + " " + endTime;	let nameChk = 0;
	for ( let key in Routes){ if ( key === routeName){ nameChk = 1; } }
	if ( nameChk === 1 ){
		alert("同じ名前のルートがあります。名前を変更してください");
		return;
	}
	let endTimObj = new Date( endTime ); let startTimObj = new Date( startTime );
	let timChk = endTimObj.getTime() - startTimObj.getTime();
	if (( timChk <= 0) || isNaN(timChk)){
		alert("正しい時間をセットしてください");
		return;
	}
	let latlonArr = [];
	for ( let i = 1; i < Object.keys(MarkerIndex).length +1; i++){
		let markerPt = MarkerIndex[String(i)];
		latlonArr.push( markerPt[1].slice() );
	}
	let eleArr = make_eleArr(latlonArr);
	let timeArr = make_timeArr( latlonArr, eleArr, startTime, endTime );
	trackName  = `<name>${trackName}<number>1<route>${routeName}<order>0`;
	let trkptDat = {}, trkDat = {}, tracks = {};
	trkptDat["latlon"] = latlonArr.slice();
	trkptDat["ele"] = eleArr.slice();
	trkptDat["time"] = timeArr.slice(); 
	trkDat["trkpts"] = { ...trkptDat};
	trkDat["line"] = [];
	tracks[trackName] = { ...trkDat};
	Routes[routeName] = { };
	Routes[routeName]["header"] =  HeaderTxt;
	Routes[routeName]["tracks"] =  { ...tracks};
  // makeルートのマーカーとラインを消去
	for ( let M in MarkerList ){ mymap.removeLayer( MarkerList[M] ); }
	mymap.removeLayer(MarkerLine);
	MarkerList = {}; MarkerIndex = {}; 
  // ルートの描画
	drw_trackLine( routeName, trackName, latlonArr );
	dsp_routeList();
	return;
}

// "save" ファイル出力
function savelog(){
	let SaveRoute = Object.keys(ChoseRoute);
	writeFilNam = document.getElementById("trk1").value;
// kml 出力モード選択を追加する場所
	writeTex = make_GPXtxt(SaveRoute); // gpx出力作成
	let title = writeFilNam + ".gpx"; // 出力ファイル名
	let linkTag = document.getElementById( "saveLocal" );
	let linkTagAttr =  ["href","download"];
	let stringObject = new Blob( [writeTex], { type: "text/plain" } );
	let objectURL = window.URL.createObjectURL( stringObject );   
	linkTag.setAttribute( linkTagAttr[0], objectURL );
	linkTag.setAttribute( linkTagAttr[1], title ); 
	document.getElementById("trk1").value ="" ;
	let deleLin = ChoseRoute[ SaveRoute ]; 
	for ( let i = 0; i < deleLin.length; i++ ){ mymap.removeLayer( deleLin[i] ); }
	delete ChoseRoute[ SaveRoute ];
	modeChange();
}
// ファイル出力用のgpx txtストリーム作成
function make_GPXtxt(SaveRoute){
	let WriteTxt = Routes[SaveRoute].header;
	let trackNarrTmp = Object.keys( Routes[SaveRoute].tracks );
	let trackNarr = trackNarrTmp.slice();
	for ( let i = 0; i < trackNarrTmp.length; i++){ trackNarr.splice(trackNarrTmp[ i ].split("<order>")[1], 1, trackNarrTmp[ i ]) }
	for ( let i = 0; i < trackNarr.length; i++){
		let TNRO = trackNarr[ i ].split("<route>");
		let TN = TNRO[0].split("<number>")
		WriteTxt += `<trk>${TN[0]}</name><number>${TN[1]}</number>\n<trkseg>\n`;
		WriteTxt += make_trackTxt( SaveRoute, trackNarr[ i ] );
		WriteTxt += `</trkseg>\n</trk>\n`;
	}
	WriteTxt += `</gpx>\n`
	return WriteTxt;
}
// 指定トラックをgpxフォーマットのtxtに変換
function make_trackTxt( Route, Track ){
	let latlonArr = Routes[Route].tracks[ Track ].trkpts.latlon;
	let eleArr = Routes[Route].tracks[ Track ].trkpts.ele;
	let tmeArr = Routes[Route].tracks[ Track ].trkpts.time;
	trackTxt = [];
	for ( let j = 0; j < latlonArr.length; j++ ){
		let latlon = latlonArr[j];
		trackTxt += `<trkpt lat="${latlon[0]}" lon="${latlon[1]}"><ele>${eleArr[j]}</ele><time>${tmeArr[j]}</time></trkpt>\n`;
	}
	return trackTxt;
}

// "edit" トラック確定
function fix_edit(){
	if ( ChoseTrack.length === 0){ return; }
	let selctRoute = ChoseTrack[0], selTrack = ChoseTrack[1];
	let latlonTmp = [], eleTmp = [], timeTmp = []
	let initMarkNumMax = Routes[selctRoute].tracks[selTrack].trkpts.latlon.length;
	let latlonPt, elePt, timePt
  // MarkerIndex の順に latlon を latlonTmp に入れる。eleTmp はMovedMark/AddedMarkにあればget_Ele()で求め、なければオリジナルの値
  // timeTmpはAddedMarkにあればブランク、なければオリジナルの値
	for ( let i = 1; i < Object.keys(MarkerIndex).length + 1; i++){
		let MrkName = MarkerIndex[String(i)][0];
		let MrkNumber = Number( MrkName.replace(/m/, "") );
		let markIndxIni = MrkNumber-1;
		latlonPt = MarkerIndex[String(i)][1].slice();
		latlonTmp.push( latlonPt );
		if ( MrkNumber <= initMarkNumMax ){
			timeTmp.push( Routes[selctRoute].tracks[selTrack].trkpts.time[ markIndxIni ] );
			if ( MovedMark.hasOwnProperty(MrkName) ){
				eleTmp.push( get_Ele( latlonPt[0], latlonPt[1] ) );
			}else{
				eleTmp.push( Routes[selctRoute].tracks[selTrack].trkpts.ele[ markIndxIni ] );
			}
		}else{
			timeTmp.push( "" );
			eleTmp.push( get_Ele( latlonPt[0], latlonPt[1] ) )
		}
	}
  // 時間ブランクのポイント時間を、前後の trkpt の時間と距離、標高差、傾斜速度比により求める
	( timeTmp[0] === "" ) ? timeTmp[0] = Routes[selctRoute].tracks[selTrack].trkpts.time[ 0 ]:   timeTmp[0] =  timeTmp[0];
	let last = timeTmp.length-1;
	( timeTmp[last] === "" ) ? timeTmp[last] = Routes[selctRoute].tracks[selTrack].trkpts.time[ initMarkNumMax - 1 ]:   timeTmp[last] =  timeTmp[last];
	for ( let i = 1; i < timeTmp.length; i++){
		let latlonPartial = [], elePartial = [], j = 0;
		if ( timeTmp[i] === "" ){
			latlonPartial.push( latlonTmp[ i -1 ] );
			elePartial.push( eleTmp[ i -1 ] );
			do{
				latlonPartial.push( latlonTmp[ i + j ] )
				elePartial.push( eleTmp[ i + j ] );
				j++;
			}while( timeTmp[ i+j ] === "" );
			latlonPartial.push( latlonTmp[ i + j ] )
			elePartial.push( eleTmp[ i + j ] );
			let startTime = timeTmp[ i -1 ];
			let endTime = timeTmp[ i+j ];
			let timePartial = make_timeArr( latlonPartial, elePartial, startTime, endTime );
			for ( let k = 1; k < timePartial.length; k++){
				timeTmp[ i - 1 + k ] = timePartial[ k ];
			}
		}
	}
	Routes[selctRoute].tracks[selTrack].trkpts.latlon = latlonTmp.slice();
	Routes[selctRoute].tracks[selTrack].trkpts.ele = eleTmp.slice();
	Routes[selctRoute].tracks[selTrack].trkpts.time = timeTmp.slice();
  // editトラックのマーカーとラインを消去
	for ( let M in MarkerList ){ mymap.removeLayer( MarkerList[M] ); }
	mymap.removeLayer(MarkerLine);
	MarkerList = {}; MarkerIndex = {}; 
  // 編集前ルート消去、編集後ルート再描画
	eras_trackLine( selctRoute, selTrack );
	drw_trackLine( selctRoute, selTrack, latlonTmp );
	latlonTmp = []; eleTmp = []; timeTmp = []; latlon = []; latlon = []; ele = []; time = []; ChoseTrack = [];
}

// "decimate" 間引き実行
function exec_decimate(){
	if ( Object.keys(ChoseRoute).length === 0){ return; }
	let interval = Number( document.getElementById("interval").value ); // 間引き間隔(m)
	let routeName = Object.keys(ChoseRoute);
	if ( chk_timeDat( routeName ) === 1 ){ return; }
  // 間引きルーチン
	for ( let track in Routes[ routeName ].tracks ){
		let latlonTmp =[],  eleTmp =[],  timeTmp = [];
		latlonArr = Routes[ routeName ].tracks[track].trkpts.latlon;
		latlonTmp = [ latlonArr[0].slice() ];
		eleTmp = [ Routes[ routeName ].tracks[track].trkpts.ele[0] ];
		timeTmp = [ Routes[ routeName ].tracks[track].trkpts.time[0] ];
		let distP = 0;
		for (let i = 1; i < latlonArr.length; i++ ){
			let lat1 = latlonArr[ i - 1 ][0], lon1 = latlonArr[ i - 1 ][1];
			let lat2 = latlonArr[ i ][0], lon2 = latlonArr[ i ][1];
			distP += hubeny( lat1, lon1, lat2, lon2 );
			if ( distP >= interval ){
				latlonTmp.push( latlonArr[ i ].slice() );
				eleTmp.push( Routes[ routeName ].tracks[track].trkpts.ele[i] );
				timeTmp.push ( Routes[ routeName ].tracks[track].trkpts.time[i] );
				distP = 0;
			}
			if ( i === latlonArr.length - 1 ){
				latlonTmp.push( latlonArr[ i ].slice() );
				eleTmp.push( Routes[ routeName ].tracks[track].trkpts.ele[i] );
				timeTmp.push ( Routes[ routeName ].tracks[track].trkpts.time[i] );
			}
		}
		Routes[ routeName ].tracks[track].trkpts.latlon = latlonTmp.slice();
		Routes[ routeName ].tracks[track].trkpts.ele = eleTmp.slice();
		Routes[ routeName ].tracks[track].trkpts.time = timeTmp.slice();
  // ルート選択ラインの消去
		let deleLin = ChoseRoute[ routeName ];
		for ( let i = 0; i < deleLin.length; i++ ){ mymap.removeLayer( deleLin[i] );  }
		delete ChoseRoute[ routeName ];
  // トラックの消去と再描画
		eras_trackLine( routeName, track );
		drw_trackLine( routeName, track, latlonTmp );
	}
	latlonTmp = []; eleTmp = []; timeTmp = []; latlonArr = []; ChoseRoute = {};
	WrtMessage1(""); dsp_routeList();
}

// Routes[ routeName ]の全トラックを統合
function unify_track( routeName ){
	let RtIndx ={};
	let trakOfRoute = Object.keys( Routes[ routeName ].tracks );
	for ( let track of trakOfRoute ){ RtIndx[ Routes[ routeName ].tracks[ track ].trkpts.time[0] ] = track; } // RtIndx{time:track, ....}
	let TTindx = Object.keys(RtIndx);
	TTindx.sort(); // TTindx[timeT1, timeT2...]
	let latlonCo =[], eleCo =[], timeCo = [];
	for ( let TM of TTindx){
		latlonCo = latlonCo.concat( Routes[ routeName ].tracks[ RtIndx[TM] ].trkpts.latlon );
		eleCo = eleCo.concat( Routes[ routeName ].tracks[  RtIndx[TM] ].trkpts.ele );
		timeCo = timeCo.concat( Routes[ routeName ].tracks[  RtIndx[TM] ].trkpts.time );
	}
	return { trackName:RtIndx[ TTindx[0] ], trkpts:{latlon:latlonCo, ele:eleCo, time: timeCo} };
}

// "merge" ルート、トラックの結合
function exec_merge(){
	if ( Object.keys(MergeList).length === 0){ return; }
	let MrgRoute = Object.keys(MergeList);
	let TrkR, rkR2, NoTime1 = NoTime2 = "";
	if ( MrgRoute.length != 1 ){
		TrkR = Object.keys( Routes[ MrgRoute[0] ].tracks );
		TrkR2 = Object.keys( Routes[ MrgRoute[1] ].tracks );
		for ( let i = 0; i < Routes[ MrgRoute[0] ].tracks[ TrkR[ 0 ] ].trkpts.time.length; i++){
			if ( Routes[ MrgRoute[0] ].tracks[ TrkR[ 0 ] ].trkpts.time[i] === "" ){ NoTime1 = MrgRoute[0]; }
		}
		for ( let i = 0; i <  Routes[ MrgRoute[1] ].tracks[ TrkR2[ 0 ] ].trkpts.time.length; i++){
			if ( Routes[ MrgRoute[1] ].tracks[ TrkR2[ 0 ] ].trkpts.time[i] === "" ){ NoTime2 = MrgRoute[1]; }
		}
		if ( NoTime1 != "" ||  NoTime2 != "" ){ 
			alert(`ルート( ${NoTime1}　${NoTime2} )に時間データがありません。\n時間変更で時間を設定してください。`);
			return;
		}
	}
	let NewName = document.getElementById("trk1").value;
	let NewTrack, tracksTmp = {};
	let latlonTmp = [], eleTmp = [], timeTmp = [];
	let unifyR1 = {}, unifyR2 = {}, trkptDatTmp = {};
	if ( document.selbttn2.ChoiceOP.value === "0" ){
		unifyR1 = unify_track( MrgRoute[0] );
		if ( MrgRoute.length === 1 ){ // 1ルートのトラック統合のみ
			let deleLin = MergeList[ MrgRoute[0] ];
			for ( let i = 0; i < deleLin.length; i++ ){ mymap.removeLayer( deleLin[i] ); }
			for ( let track in Routes[ MrgRoute[0] ].tracks ){ eras_trackLine( MrgRoute[0], track ); }
			Routes[ MrgRoute[0] ].tracks ={};
			Routes[ MrgRoute[0] ].tracks[unifyR1.trackName] = { trkpts: {...unifyR1.trkpts} };
			drw_trackLine( MrgRoute[0], unifyR1.trackName, unifyR1.trkpts.latlon );
			MergeList = {};
			modeChange();
			return;
		}else{ // 2ルートのトラック統合されたtrkptsを時系列で統合
			unifyR2= unify_track( MrgRoute[1] );
			let MaxCountR1 = MaxCountR2 = i = j = 0;
			MaxCountR1 = unifyR1.trkpts.time.length; MaxCountR2 = unifyR2.trkpts.time.length;
			while ( i < MaxCountR1 && j < MaxCountR2 ){
				if ( unifyR1.trkpts.time[i] < unifyR2.trkpts.time[j] ){
					latlonTmp.push( unifyR1.trkpts.latlon[i] ); eleTmp.push( unifyR1.trkpts.ele[i] ); timeTmp.push( unifyR1.trkpts.time[i] ); i++;
				}else{
					latlonTmp.push( unifyR2.trkpts.latlon[j] ); eleTmp.push( unifyR2.trkpts.ele[j] ); timeTmp.push( unifyR2.trkpts.time[j] ); j++;
				}
			}
			if ( i === MaxCountR1 ){
				while ( j < MaxCountR2 ){
					latlonTmp.push( unifyR2.trkpts.latlon[j] ); eleTmp.push( unifyR2.trkpts.ele[j] ); timeTmp.push( unifyR2.trkpts.time[j] ); j++;
				}
			}else{
				while ( i < MaxCountR1 ){
					latlonTmp.push( unifyR1.trkpts.latlon[i] );eleTmp.push( unifyR1.trkpts.ele[i] ); timeTmp.push( unifyR1.trkpts.time[i] ); i++;
				}
			}
			( document.selbttn3.ChoiceOP.value === "0" ) ? NewTrack = unifyR1.trackName: NewTrack = unifyR2.trackName;
			tracksTmp[ NewTrack ] = { trkpts:{ latlon:latlonTmp, ele:eleTmp, time: timeTmp } };
		}
		Routes[ NewName ] = {};
		let header = "";
		( document.selbttn3.ChoiceOP.value === "0" ) ?  header = Routes[ MrgRoute[0] ].header:  header = Routes[ MrgRoute[1] ].header; 
		Routes[ NewName ].header = header;
		Routes[ NewName ].tracks = { ...tracksTmp };
		for ( let j = 0; j < MrgRoute.length; j++ ){
			let deleLin = MergeList[ MrgRoute[j] ];
			for ( let i = 0; i < deleLin.length; i++ ){ mymap.removeLayer( deleLin[i] ); }
			for ( let track in Routes[ MrgRoute[j] ].tracks ){ eras_trackLine( MrgRoute[j], track ); }
			delete Routes[ MrgRoute[j] ];
		}
		for ( let track in Routes[NewName ].tracks ){ drw_trackLine( NewName, track, Routes[ NewName ].tracks[ track ].trkpts.latlon ); }
		latlonTmp = []; eleTmp = []; timeTmp = []; tracksTmp = {}; unifyR1 = {}; unifyR2 = {}; trkptDatTmp = {};
		MergeList = {}; WrtMessage1("");
		modeChange();
		return;
	}else{ // 2ルートのトラックを時系列でラック単位で並び替え
		if ( MrgRoute.length === 1 ){ return; }
		TrkR = TrkR.concat( TrkR2 );
		let TimeTrack = [];
		for ( let i = 0; i < TrkR.length; i++ ){
			let RO = TrkR[ i ].split("<route>")[1];
			let Route = RO.split("<order>")[0];
			let Ptime = Routes[ Route ].tracks[ TrkR[ i ] ].trkpts.time[0];
			TimeTrack.push( Ptime + TrkR[ i ] );
		}
		TimeTrack.sort();
		let routeTxt = "";
		( document.selbttn3.ChoiceOP.value === "0" ) ?  routeTxt = Routes[ MrgRoute[0] ].header:  routeTxt = Routes[ MrgRoute[1] ].header; 
		for ( let i = 0; i < TimeTrack.length; i++ ){
			let TNRO = TimeTrack[ i ].split("<name>")[1];
			let TN = TNRO.split("<route>")[0];
			let RO = TNRO.split("<route>")[1];
			let Route = RO.split("<order>")[0];
			let Trk = TN.split("<number>")[0];
			let Num = TN.split("<number>")[1];
			let trkTxt = `<trk><name>${Trk}</name><number>${Num}</number><trkseg>\n`;
			routeTxt += trkTxt + make_trackTxt( Route, "<name>" + TNRO  );
			routeTxt += "</trkseg>\n</trk>\n";
		}
		routeTxt += "</gpx>\n";
  // ルート選択ラインの消去
		for ( let j = 0; j < MrgRoute.length; j++ ){
			let deleLin = MergeList[ MrgRoute[j] ];
			for ( let i = 0; i < deleLin.length; i++ ){ mymap.removeLayer( deleLin[i] ); }
			for ( let track in Routes[ MrgRoute[j] ].tracks ){ eras_trackLine( MrgRoute[j], track ); }
			delete Routes[ MrgRoute[j] ];
		}
		make_route_datArr(routeTxt, NewName, 1);
		MergeList = {};
		modeChange();
		return;
	}
}

// "TmChang" 時間変更 
function change_time(){
	if ( Object.keys(ChoseRoute).length === 0){ return; }
	let TcDate = document.getElementById("SetTime-date").value;
	let TcStartTime = document.getElementById("SetTime-start").value;
	let TcEndTime = document.getElementById("SetTime-end").value;
	let startTime = TcDate + " " + TcStartTime; 
	let endTime =  TcDate + " " + TcEndTime;
	let endTimObj = new Date( endTime ); let startTimObj = new Date( startTime );
	let timChk = endTimObj.getTime() - startTimObj.getTime();
	if (( timChk <= 0) || isNaN(timChk)){
		alert("正しい時間をセットしてください");
		return;
	}
	let latlonTmp = [], eleTmp = [], timeTmp = [];
	let TcRoute = Object.keys(ChoseRoute)[0];
	for ( let track  in Routes[ TcRoute ].tracks ){
		latlonTmp = latlonTmp.concat( Routes[TcRoute].tracks[track].trkpts.latlon );
		eleTmp =  eleTmp.concat( Routes[TcRoute].tracks[track].trkpts.ele );
	}
	timeTmp = make_timeArr( latlonTmp, eleTmp, startTime, endTime );
	let Tc = 0;
	for ( let track in Routes[TcRoute].tracks ){
		for ( let i = 0; i < Routes[TcRoute].tracks[track].trkpts.time.length; i++ ){
			Routes[TcRoute].tracks[track].trkpts.time[ i ] = timeTmp[ Tc ];
			Tc++;
		}
	}
  // ルート選択ラインの消去
	let deleLin = ChoseRoute[ TcRoute ]; 
	for ( let i = 0; i < deleLin.length; i++ ){ mymap.removeLayer( deleLin[i] ); }
	delete ChoseRoute[ TcRoute ];
	latlonTmp = []; eleTmp = []; timeTmp = [];
	modeChange();
}

// "NaChang" ルート、トラック名変更
function change_RTname(){
	if ( Object.keys(ChoseRoute).length === 0){ return; }
	let ChRt = Object.keys(ChoseRoute);
	let CurTrackName = Object.keys( Routes[ ChRt[0] ].tracks );
	let NewRouteName = document.getElementById("trk1").value;
	let TracksTxt = document.getElementById("trk2").value;
	let trakNameArr = TracksTxt.split("\n");
	let errFlg = 0;
	trakNameArr.length = CurTrackName.length;
	for ( let i = 0; i < trakNameArr.length; i++ ){
		if ( trakNameArr[ i ].indexOf("<name>") === -1 || trakNameArr[ i  ].indexOf("<number>") === -1 ){ errFlg = 1; }
	}
	if ( errFlg != 0){
		alert( 'トラック名は "<name>名前<number>番号" の書式で、\nトラック数と同じ行数で記述してください。\n(名前、番号を付けない時は"<name><number>" )' );
		return;
	}
	let routeTxt = make_GPXtxt( ChRt[0] );
	let routeTxtBlock = routeTxt.split("<trk>")
	let NewRrouteTxt = routeTxtBlock[ 0 ] + "<trk>";
	for ( let i = 1; i < routeTxtBlock.length; i++ ){
		let tempTN = trakNameArr[ i - 1 ].split("<number>");
		let sectTN = "<trk>" + tempTN[0] + "</name><number>" + tempTN[1]+ "</number>";
		NewRrouteTxt += sectTN + routeTxtBlock[ i ].split("</number>")[1]
	}
	let deleLin = ChoseRoute[ ChRt[0] ]; 
	for ( let i = 0; i < deleLin.length; i++ ){ mymap.removeLayer( deleLin[i] ); }
	delete ChoseRoute[ ChRt[0] ];
	for ( let track in Routes[ ChRt[0] ].tracks ){ eras_trackLine( ChRt[0], track ); }
	delete Routes[ ChRt[0] ];
	make_route_datArr(NewRrouteTxt, NewRouteName, 1);
	modeChange();
}

// "divide" ルート分割（始点から分割点の前まで、分割点を含み終点まで）
function divide_route(){
	if ( Object.keys(DevideMark).length === 0){ return; }
	let routeName1 = document.getElementById("trk1").value;
	let routeName2 = document.getElementById("trk2").value;
	let DivRoute = DevideMark["0"].route;
	if ( chk_timeDat( DivRoute ) === 1 ){ return; }
	let MkIndx = DevideMark["0"].indx;
	let DivTrack = DevideMark["0"].track;
	let MarkTimeTxt =  Routes[ DivRoute ].tracks[DivTrack].trkpts.time[MkIndx];
	let routeTxt = make_GPXtxt(DivRoute);
	let header = routeTxt.substring( 0, routeTxt.indexOf("<trk>") );
	let routeTxtDiv = routeTxt.split(MarkTimeTxt);
	let route1txt = routeTxtDiv[0];
	if ( routeTxtDiv.length > 2 ){
		for ( let i = 1; i < routeTxtDiv.length - 1 ; i++ ){ routeTxtDiv[ i ] += MarkTimeTxt; }
		for ( let i = 2; i < routeTxtDiv.length ; i++ ){ routeTxtDiv[ 1 ] += routeTxtDiv[ i ]; }
	}
	let route2txt = routeTxtDiv[1];
	route2txt = route1txt.substring( route1txt.lastIndexOf("<trkpt lat") ) + MarkTimeTxt + route2txt;
	route1txt = route1txt.substring( 0, route1txt.lastIndexOf("<trkpt lat") );
	let trkR2 = "";
	if ( MkIndx === 0 ){
		route2txt = header + route1txt.substring( route1txt.lastIndexOf("<trk>") ) + route2txt;
		route1txt = route1txt.substring( 0, route1txt.lastIndexOf("<trk>") ) + "</gpx>";
	}else if ( MkIndx === 1 ){
		trkR2 = route1txt.substring( route1txt.lastIndexOf("<trk>"), route1txt.lastIndexOf("<trkpt lat") );
		route2txt = header +trkR2 + route2txt;
		route1txt = route1txt.substring( 0, route1txt.lastIndexOf("<trk>") ) + "</gpx>";
	}else if ( MkIndx === Routes[ DivRoute ].tracks[DivTrack].trkpts.time.length - 1 ) {
		let pt1 = route2txt.substring( 0, route2txt.indexOf("</trkseg>") );
		let P1 = route2txt.indexOf("<trk>");
		let P2 = route2txt.indexOf("<trkpt lat", P1);
		trkR2 = route2txt.substring( P1, P2 );
		route2txt = route2txt.substring( P2 );
		route2txt = header + trkR2 + pt1 + route2txt;
		route1txt = route1txt + "</trkseg></trk></gpx>";
	}else{
		trkR2 = route1txt.substring( route1txt.lastIndexOf("<trk>"), route1txt.indexOf( "<trkpt lat", route1txt.lastIndexOf("<trk>") ) );
		route2txt = header +trkR2 + route2txt;
		route1txt = route1txt + "</trkseg></trk></gpx>";
	}
	mymap.removeLayer(DevideMark["0"].mark);
	DevideMark = {};
	for ( let track in Routes[ DivRoute ].tracks ){ eras_trackLine( DivRoute, track ); }
	delete Routes[ DivRoute ];
	make_route_datArr(route1txt, routeName1, 1);
	make_route_datArr(route2txt, routeName2, 1);
	modeChange();
}

// "remove" ルートの部分削除
function patial_remove(){
	if ( Object.keys(DevideMark).length === 0){ return; }
	let rmvMode = document.selbttn2.ChoiceOP.value;
	if ( rmvMode === "1" || rmvMode === "2"){
		if ( Object.keys(DevideMark).length === 1 ){ return; }
	}
	let divPoint = [], dpTr = {}, Rname, Tname, INDX;
	for ( let Mnum in DevideMark ){
		Rname = DevideMark[Mnum].route;
		if ( chk_timeDat( Rname ) === 1 ){ return; }
		Tname = DevideMark[Mnum].track;
		INDX = DevideMark[Mnum].indx;
		let dpTime = Routes[Rname].tracks[Tname].trkpts.time[INDX]
		divPoint.push( dpTime );
		dpTr[dpTime] = Tname;
	}
	divPoint.sort();
	let RouteTxt = make_GPXtxt(Rname);
	let cutPoint = chk1 =chk2 = routeTxtNew = trkLinTxt = temp1 = temp2 = "";
	let RtnCutPre = [];
	if ( rmvMode === "0" ){
		RtnCutPre = cut_pre( RouteTxt, divPoint[0] );
		routeTxtNew = Routes[Rname].header + RtnCutPre[1] + RtnCutPre[0];
	}else if ( rmvMode === "1" ){
		temp1 = cut_post( RouteTxt, divPoint[0] );
		RtnCutPre = cut_pre( RouteTxt, divPoint[1] );
		temp2 = RtnCutPre[0];
		routeTxtNew = temp1 + temp2;
	}else if ( rmvMode === "2" ){
		RtnCutPre = cut_pre( RouteTxt, divPoint[0] );
		temp1 = cut_post( RtnCutPre[0], divPoint[1] );
		routeTxtNew = Routes[Rname].header + RtnCutPre[1] + temp1 + "</trkseg>\n</trk>\n</gpx>";
	}else if ( rmvMode === "3" ){
		routeTxtNew = cut_post( RouteTxt, divPoint[ divPoint.length -1 ] ) + "</trkseg>\n</trk>\n</gpx>";
	}
	for ( let Mn in DevideMark) {
		mymap.removeLayer( DevideMark[Mn].mark );
	}
	DevideMark = {};
	for ( let track in Routes[Rname].tracks ){ eras_trackLine( Rname, track ); }
	delete Routes[Rname];
	make_route_datArr(routeTxtNew, Rname, 1);
	dsp_routeList();
	return;
}
function cut_pre( RouteTxt, cutPoint ){ // ルート部分削除(マーカー以前)
	let SplTxt = RouteTxt.split( cutPoint );
	if ( SplTxt.length > 2 ){
		let pstTmp = "";
		for ( let i = 1; i < SplTxt.length; i++ ){ pstTmp += SplTxt[i]; }
		SplTxt[1] = pstTmp;
	}
	let  cutPreTxt = SplTxt[1];
	let trakTxt = SplTxt[0].substring( SplTxt[0].lastIndexOf("<trk>"), SplTxt[0].indexOf( "<trkpt lat", SplTxt[0].lastIndexOf("<trk>") ) );
	let chkStr = cutPreTxt.substring( 0, cutPreTxt.indexOf( "<trkpt lat" ) );
	cutPreTxt = SplTxt[0].substring( SplTxt[0].lastIndexOf( "<trkpt lat" ) ) + cutPoint + cutPreTxt;
	if ( chkStr.indexOf( "<trk>" ) != -1 ){
		let trkpt1st =SplTxt[0].substring( SplTxt[0].lastIndexOf( "<trkpt lat" ) ) + cutPoint + "</time></trkpt>\n";
		trakTxt = cutPreTxt.substring( cutPreTxt.indexOf( "<trk>" ), cutPreTxt.indexOf( "<trkpt lat" ) );
		cutPreTxt = trkpt1st + SplTxt[1].substring(  SplTxt[1].indexOf( "<trkpt lat" ) );
	}
	return [ cutPreTxt, trakTxt ];
}
function cut_post( RouteTxt, cutPoint ){ // ルート部分削除(マーカー以後)
	let SplTxt = RouteTxt.split( cutPoint );
	let cutPostTxt = SplTxt[0];
	let chkStr = cutPostTxt.substring( cutPostTxt.lastIndexOf( "</trkpt>" ) );
	cutPostTxt = cutPostTxt + cutPoint + "</time></trkpt>\n";
	if ( chkStr.indexOf( "<trk>" ) != -1 ){
		let trkptLast = cutPostTxt.substring( cutPostTxt.lastIndexOf("<trkpt lat") );
		cutPostTxt = cutPostTxt.substring( 0, cutPostTxt.lastIndexOf("</trkseg>") );
		cutPostTxt = cutPostTxt + trkptLast;
	}
	return cutPostTxt;
}

// "Pinfo" trkptポイントの時間変更(Pinfoで示した1点だけ)
function chg_pointTime(){
	let newTime = document.getElementById("ChgTime").value;
	let CurTime = Routes[ DevideMark["0"].route ].tracks[ DevideMark["0"].track ].trkpts.time[ DevideMark["0"].indx ];
	let CTobj = new Date( CurTime.slice("T")[0] + " " + newTime );
	Routes[ DevideMark["0"].route ].tracks[ DevideMark["0"].track ].trkpts.time[ DevideMark["0"].indx ] = CTobj.toISOString().split('.')[0] + "Z"
}

// "jump" 地図ジャンプ
function junp_select(){
	let placeN = Number(document.selbttn2.ChoiceOP.value);
	let SVconst = jumpList[ placeN ].split("/");
	mymap.setView([SVconst[2], SVconst[3]], SVconst[1] );
	document.selbttn1.mode.value = "make";
	modeChange();
}

// "reverse" 逆ルート変換
function make_reverseRoute(){
	if ( Object.keys(ChoseRoute).length === 0){ return; }
	let FowRName = Object.keys(ChoseRoute)[0];
	let RevRName = document.getElementById("trk1").value;
	let nameChk = 0;
	for ( let key in Routes){ if ( key === RevRName){ nameChk = 1; } }
	if ( nameChk === 1 ){
		alert("同じ名前のルートがあります。名前を変更してください");
		return;
	}
	let routeTxtFow = make_GPXtxt(FowRName);
	FowtxtBlkArr = routeTxtFow.split("<trk>");
	FowtxtBlkArr.shift();
	let routeTxtRev = "";
	for ( let  i = FowtxtBlkArr.length - 1 ; i > -1; i--){
		let ChgOrdTrack = FowtxtBlkArr[ i ];
		routeTxtRev += "<trk>" + ChgOrdTrack.split("<trkseg>")[0] + "<trkseg>\n" ; // <trk>～<trkseg>
		ChgOrdTrack = ChgOrdTrack.split("<trkseg>")[1];
		COTarr = ChgOrdTrack.split("</trkpt>")
		COTarr.pop();
		for ( let j = COTarr.length -1; j > -1; j--){
			routeTxtRev += COTarr[ j ].split("<time>")[0] + "<time></time></trkpt>"
		}
		routeTxtRev += "</trkseg>\n</trk>"
	}
	routeTxtRev = HeaderTxt + routeTxtRev + "\n</gpx>";
  // 順方向ルートの消去
	for ( let track in Routes[FowRName].tracks ){ eras_trackLine( FowRName, track ); }
	delete Routes[FowRName];
	make_route_datArr(routeTxtRev, RevRName, 1);
  // ルート選択ラインの消去
	let deleLin = ChoseRoute[ FowRName ]; 
	for ( let i = 0; i < deleLin.length; i++ ){ mymap.removeLayer( deleLin[i] ); }
	delete ChoseRoute[ FowRName ];
	modeChange();
}

// ルートリストのダブルクリックで地図ジャンプ
function listJump(){
	let keyword = selRoute = "";
	keyword = String(getSelection()).replace(/{.*}/,'');
	if ((!keyword) || (keyword === " ") || (keyword === ".") || (keyword === "\n") ){ return; }
	routeNaArr = Object.keys(Routes);
	for ( let route in Routes ){
		if ( route.indexOf( keyword ) != -1 ){
			selRoute = route;
			break;
		}
	}
	let latlonAll = [];
	for ( let track in Routes[selRoute].tracks){
		let LineLatlon = Routes[selRoute].tracks[track].trkpts.latlon;
		latlonAll = latlonAll.concat( LineLatlon );
	}
	 mymap.fitBounds( latlonAll );
	latlonAll = [];
}

</script>
</body>
</html>

